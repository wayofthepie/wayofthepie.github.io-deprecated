<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Wayofthepie - Building An Assembler In Haskell</title>
    <link rel="stylesheet" type="text/css" href="../css/syntax.css">
    <link rel="stylesheet" type="text/css" href="../css/fluff.css">
    <link rel="stylesheet" type="text/css" href="../css/fix.css">
    <link rel="stylesheet" type="text/css" href="../css/github.css">
    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-social/5.1.1/bootstrap-social.min.css" crossorigin="anonymous">
    <link type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
    <!-- Google Analytics -->
    <script>
     (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
         (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

     ga('create', 'UA-114311995-1', 'auto');
     ga('send', 'pageview');
    </script>
    <!-- End Google Analytics -->
</head>
<body>
<div id="header">
    <!-- Fixed navbar -->
    <nav class="navbar navbar-inverse navbar-top">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="../index.html">
                    Software Pie
                </a>
            </div>
            <div id="navbar" class="navbar-collapse collapse">
                <ul class="nav navbar-nav">
                    <li class="inactive"><a href="../index.html">Home</a></li>
                    <li class="inactive"><a href="../archive.html">Archives</a></li>
                </ul>
            </div><!--/.nav-collapse -->
        </div>
    </nav>
</div>

<div class="container theme-showcase" role="main">
    <div id="content">
        <div class="page-header">
            <h1>Building An Assembler In Haskell</h1>
        </div>
        <div class="info">
    Posted on March  3, 2017
    
</div>
<div class="info">
  
    Tags: <a href="../tags/haskell.html">haskell</a>, <a href="../tags/emulator.html">emulator</a>
  
</div>
<h3>Table of contents</h3><ul>
<li><a href="#mos-tech-6502">MOS Tech 6502</a></li>
<li><a href="#the-language">The Language</a></li>
<li><a href="#building-our-parser">Building Our Parser</a><ul>
<li><a href="#property-driven-parser-development">Property Driven Parser Development</a><ul>
<li><a href="#generating-our-data---quickcheck-arbitrary">Generating Our Data - QuickCheck Arbitrary</a></li>
<li><a href="#building-our-property">Building Our Property</a></li>
<li><a href="#implementation">Implementation</a></li>
</ul></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h1 id="mos-tech-6502">MOS Tech 6502</h1>
<p>Recently I started building an emulator for the MosTech 6502 Cpu, this post is about the initial stages of building an assembler for a simple assembly language that compiles to runnable 6502 machine code. I’ve created a repo and updated it as I wrote this post, so at the end of most sections that introduce new code I’ll link to a commit which has the code up to that point.</p>
<p>You can see the repo here: <a href="https://github.com/wayofthepie/emu-mos6502-asm-blog/tree/hasm-blog01" class="uri">https://github.com/wayofthepie/emu-mos6502-asm-blog/tree/hasm-blog01</a>. The only pre-requisite is installing <a href="https://docs.haskellstack.org/en/stable/README/#how-to-install">stack</a>, once the project is cloned you can use <code>stack install</code> to install dependencies and build the project.</p>
<h1 id="the-language">The Language</h1>
<p>First, let’s define what we want our assembly language to be able to do. To keep it simple, we only want to allow assignment and the definition of instructions for now:</p>
<ul>
<li>We should be able to define instructions and their operands, e.g. <code>LDA #$20</code>. This says load the value $20 into the accumulator.
<ul>
<li><code>LDA</code> means load date into the accumulator</li>
<li><code>#</code> means this is immediate addressing so use the operand as a <em>value</em> not as an address.</li>
<li><code>$20</code> stands for <code>20</code> in hexadecimal</li>
</ul></li>
<li>We should be able to assign values to variables, e.g. <code>LOCATION = $2020</code>.
<ul>
<li>Now anywhere we see <code>LOCATION</code> we can replace with <code>$2020</code>.</li>
</ul></li>
</ul>
<p>Now for a quick and dirty grammar for our simple language:</p>
<pre><code>&lt;expr&gt;        := &lt;instruction&gt; | &lt;assignment&gt;
&lt;assignment&gt;  := &lt;label&gt; &quot;=&quot; &lt;bytes&gt;
&lt;instruction&gt; := [&lt;label&gt; &quot;:&quot;] &lt;menmonic&gt; [&lt;label&gt; | &lt;operand&gt;]
&lt;operand&gt;     := [&quot;#&quot;] &lt;bytes&gt;
&lt;bytes&gt;       := &quot;$&quot; &lt;byte&gt; [&lt;byte&gt;]
&lt;label&gt;       := ([A-Za-z]*[A-Za-z0-9]*)
&lt;mnemonic&gt;    := 3 * ([A-Z])
&lt;byte&gt;        := 2 * ([A-Fa-f0-9])</code></pre>
<p>The above is a variation of EBNF (Extended Backus Naur Form) notation, we allow regular expressions (denoted by brackets <code>()</code> e.g. <code>([A-Z])</code> denotes a single upper case letter) for simplicity.</p>
<p>Here’s a breakdown, from the bottom up:</p>
<ul>
<li><code>&lt;byte&gt;</code> is defined as <code>2 * ([A-Fa-f0-9])</code>, this means two consecutive characters that are upper or lower case letters betwen <code>A</code> and <code>F</code> or digits, i.e. a two digit hexadecimal value.
<ul>
<li>e.g. <code>2F</code></li>
</ul></li>
<li><code>&lt;mnemonic&gt;</code> is a three letter string - all upper case.
<ul>
<li>e.g. <code>LDA</code></li>
</ul></li>
<li><code>&lt;label&gt;</code> is an alphanumeric string of any size, which must start with a letter.
<ul>
<li>e.g. <code>Stor3</code></li>
<li>Note that we <em>should</em> limit it’s size, but lets leave it infinite for now!</li>
</ul></li>
<li><code>&lt;bytes&gt;</code> is a string which starts with a <code>$</code> and must contain at least one <code>&lt;byte&gt;</code>, at most two.
<ul>
<li>e.g. <code>$2F</code></li>
</ul></li>
<li><code>&lt;operand&gt;</code> starts with an optional <code>#</code> followed by <code>&lt;bytes&gt;</code>.
<ul>
<li>e.g. <code>#$2f</code></li>
</ul></li>
<li><code>&lt;instruction&gt;</code> starts with an optional <code>&lt;label&gt;</code> which <em>must</em> be followed by a <code>:</code> if it exists, this is followed by a <code>&lt;mnemonic&gt;</code> and finally an optional <code>&lt;label&gt;</code> <em>xor</em> an <code>&lt;operand&gt;</code>. Some instructions use implicit addressing and require no operand or label, hence why this is optional.
<ul>
<li>e.g. <code>LABEL LDA #$20</code></li>
<li>Note that the possible label at the end is only for certain instructions, for example <code>BNE LABEL</code> will jump to the address corresponding to <code>LABEL</code> if the zero flag is not set.</li>
</ul></li>
<li><code>&lt;assignment&gt;</code> simply an <code>=</code> with a <code>&lt;label&gt;</code> on the left hand side and a <code>&lt;bytes&gt;</code> on the right.
<ul>
<li>e.g. <code>STORE = $2020</code></li>
</ul></li>
<li>Finally an <code>&lt;expr&gt;</code> can be either an <code>&lt;instruction&gt;</code> or an <code>&lt;assignment&gt;</code>.</li>
</ul>
<p>An example program would look as follows.</p>
<pre class="no-highlight"><code>LDA #$01
CMP #$02
BNE notequal
STA $22
notequal: BRK</code></pre>
<p>And the machine code this compiles to <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>:</p>
<pre class="no-highlight"><code>a9 01 c9 02 d0 02 85 22 00</code></pre>
<p>Now that the language is somewhat spec’d out, we have an nice overview of how we can start building a parser for it. There are a lot of rules not defined in the above spec, for example a <code>&lt;label&gt;</code> cannot match a mnemonic - e.g. <code>LDA</code> cannot be a <code>&lt;label&gt;</code> - let’s not worry about these for now.</p>
<h1 id="building-our-parser">Building Our Parser</h1>
<p>Now that we have our grammar, we can start thinking about how we want to build our parser. Normally I would work out some types first along with some top-level functions and go from there, so lets do that.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Assembler</span> <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span> <span class="co">-- from the &quot;text&quot; package</span>
<span class="kw">import </span><span class="dt">Text.Megaparsec</span>  <span class="co">-- from the &quot;megaparsec&quot; package</span>

<span class="co">-- | Create a custom parser type. This is megaparsec specific, we will gloss over this in</span>
<span class="co">-- this post.</span>
<span class="kw">type</span> <span class="dt">Parser</span> <span class="fu">=</span> <span class="dt">Parsec</span> <span class="dt">Dec</span> <span class="dt">T.Text</span>

<span class="co">-- | A Label is just a Text value.</span>
<span class="kw">newtype</span> <span class="dt">Label</span> <span class="fu">=</span> <span class="dt">Label</span> <span class="dt">T.Text</span> <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="co">-- | Indicates whether an address/ value is preceeded by a &quot;#&quot;.</span>
<span class="kw">newtype</span> <span class="dt">IsImmediate</span> <span class="fu">=</span> <span class="dt">IsImmediate</span> <span class="dt">Bool</span> <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="co">-- | An address/value of one or two bytes which may have a &quot;#&quot;, meaning</span>
<span class="co">-- immediate, before it.</span>
<span class="kw">data</span> <span class="dt">Operand</span> <span class="fu">=</span> <span class="dt">Operand</span> <span class="dt">IsImmediate</span> <span class="dt">T.Text</span> <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="co">-- | A three letter upper case string.</span>
<span class="kw">newtype</span> <span class="dt">Mnemonic</span> <span class="fu">=</span> <span class="dt">Mnemonic</span> <span class="dt">T.Text</span> <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="co">-- | A label, which should be assigned a value.</span>
<span class="kw">newtype</span> <span class="dt">Var</span> <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">Label</span>  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="co">-- | A value, which should be assigned to a Var.</span>
<span class="kw">newtype</span> <span class="dt">Val</span> <span class="fu">=</span> <span class="dt">Val</span> <span class="dt">T.Text</span> <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="co">-- | Either a label or an operand.</span>
<span class="kw">data</span> <span class="dt">LabelOrOperand</span> <span class="fu">=</span> <span class="dt">Lbl</span> <span class="dt">Label</span> <span class="fu">|</span> <span class="dt">Op</span> <span class="dt">Operand</span> <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="co">-- | Either an instruction or an assignment.</span>
<span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Instruction</span> (<span class="dt">Maybe</span> <span class="dt">Label</span>) <span class="dt">Mnemonic</span> (<span class="dt">Maybe</span> <span class="dt">LabelOrOperand</span>)
  <span class="fu">|</span> <span class="dt">Assignment</span> <span class="dt">Var</span> <span class="dt">Val</span>
  <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
<p>Most of the values will just be strings (<code>Text</code> types) so to distinguish between them we wrap <code>Text</code> in a <code>newtype</code> wrapper for each type we care about. For now we’re not going to worry about constructing anything other than strings (I’ll be using the type <code>Text</code> to denote strings instead of the built-in <code>String</code> in this post <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>). Looking back at our grammar we have eight symbols, each one can be represented as a function which is itself a parser for some subset of the grammar. So the <em>top-level</em> functions in this case would be the <em>symbols</em> in our grammar - <code>&lt;expression&gt;</code>, <code>&lt;label&gt;</code> etc… We’ll also add an extra function here for parsing label assignment - labels with a “:” after them as in the first part of <code>&lt;instruction&gt;</code> - let’s call it <code>labelAssign</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">expression ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
expression <span class="fu">=</span> undefined

<span class="ot">assignment ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
assignment <span class="fu">=</span> undefined

<span class="ot">instruction ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
instruction <span class="fu">=</span> undefined

<span class="ot">operand ::</span> <span class="dt">Parser</span> <span class="dt">Operand</span>
operand <span class="fu">=</span> undefined

<span class="ot">bytes ::</span> <span class="dt">Parser</span> <span class="dt">T.Text</span>
bytes <span class="fu">=</span> undefined

<span class="ot">labelAssign ::</span> <span class="dt">Parser</span> <span class="dt">Label</span>
labelAssign <span class="fu">=</span> undefined

<span class="ot">label ::</span> <span class="dt">Parser</span> <span class="dt">Label</span>
label <span class="fu">=</span> undefined

<span class="ot">mnemonic ::</span> <span class="dt">Parser</span> <span class="dt">Mnemonic</span>
mnemonic <span class="fu">=</span> undefined

<span class="ot">byte ::</span> <span class="dt">Parser</span> <span class="dt">T.Text</span>
byte <span class="fu">=</span> undefined</code></pre></div>
<p>All functions are <code>undefined</code> so the type checker will pass before we begin to implement the logic. With our grammar, we know what each symbol corresponds to, so we can use <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a> to write properties for each function that adhere to its specification in the grammar.</p>
<h2 id="property-driven-parser-development">Property Driven Parser Development</h2>
<p>To build the parser I’m going to use a parser combinator library called <a href="https://mrkkrp.github.io/megaparsec/">megaparsec</a>. I won’t go into much detail on megaparsec or parser combinators in this post, simply put, parser combinators are a way of building more complex parsers by combining parsers.</p>
<p>The simplest parser above would be <code>byte</code>, from our grammar this is just a two character hexadecimal string. Before we start implementing it, let’s write a property which encodes what we expect it to do.</p>
<h3 id="generating-our-data---quickcheck-arbitrary">Generating Our Data - QuickCheck Arbitrary</h3>
<p>Using QuickCheck to test parsers is really simple and quite powerful. It involves writing properties which encode expectations about the ouput of a function given some input.</p>
<p>To build a property for <code>byte</code> first we need to create an <a href="https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Arbitrary.html#t:Arbitrary">Arbitrary</a> instance <a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> for the data it expects - two character hexadecimal strings. Creating an instance of <code>Arbitrary</code> for a type allows random values of that type to be generated, by default QuickCheck will generate 100 random values of the type each test run. For <code>byte</code> this might look as follows.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Wrapper for our two character hexadecimal strings.</span>
<span class="kw">newtype</span> <span class="dt">TwoCharHexString</span> <span class="fu">=</span> <span class="dt">TwoCharHexString</span> <span class="dt">T.Text</span> <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">TwoCharHexString</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    upper <span class="ot">&lt;-</span> choose (<span class="ch">'A'</span>, <span class="ch">'F'</span>)
    lower <span class="ot">&lt;-</span> choose (<span class="ch">'a'</span>, <span class="ch">'f'</span>)
    num   <span class="ot">&lt;-</span> choose (<span class="ch">'0'</span>, <span class="ch">'9'</span>)
    <span class="kw">let</span> vals <span class="fu">=</span> [upper, lower, num]
    x <span class="ot">&lt;-</span> elements vals
    y <span class="ot">&lt;-</span> elements vals
    pure <span class="fu">$</span> <span class="dt">TwoCharHexString</span> (T.pack (x<span class="fu">:</span>[y]))</code></pre></div>
<p>Here we define a <code>newtype</code> called <code>TwoCharHexString</code>, which is just a wrapper for <code>Text</code>. Then we create an <code>Arbitrary</code> instance for this type which builds two character hex string <code>Text</code> values. Let’s run through the instance:</p>
<ul>
<li><a href="https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Gen.html#v:choose">choose</a> generates a random element in the given range, <code>choose (1, 4)</code> generates integers between 1 and 4 inclusive.</li>
<li><a href="https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Gen.html#v:elements">elements</a> generates a single value from the given list.</li>
<li>With these functions we can generate <code>x</code> and <code>y</code> and build our two character string by building a two element list of characters made up of <code>x</code> and <code>y</code> - see <code>x:[y]</code> above, this is just a <code>String</code> which is a list of <code>Char</code> - we then pack this with <code>T.pack</code> to get our <code>Text</code> value.</li>
</ul>
<h3 id="building-our-property">Building Our Property</h3>
<p>Next we need to write a property that defines what should happen when <code>byte</code> parses these string values.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">prop_byte_parse (<span class="dt">TwoCharHexString</span> s) <span class="fu">=</span> parse byte <span class="st">&quot;&quot;</span> s  <span class="ot">`shouldParse`</span> s</code></pre></div>
<p>This is simply a function called <code>prop_byte_parse</code> which takes a value of type <code>TwoCharHexString</code> runs the parser <code>byte</code> with the megaparsec <code>parse</code> function <a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> and checks that the result is as expected, in this case parsing a string <code>s</code> should return that same string. <code>parse</code> is a function from the <em>megaparsec</em> package which runs our parser on the supplied string.</p>
<p>Finally, <code>shouldParse</code> is a function from <a href="https://hackage.haskell.org/package/hspec-megaparsec">hspec-megaparsec</a> - a library containing utility functions for testing parsers built with megaparsec. Here we are using it to say <code>parse byte &quot;&quot; s</code> should parse to the string <code>s</code> - meaning the <code>byte</code> parser run on string <code>s</code> should just give us back <code>s</code>.</p>
<p>Let’s add this to our spec so the property check gets run when we launch <code>stack test</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">asmSpec <span class="fu">=</span> <span class="kw">do</span>
  describe <span class="st">&quot;byte&quot;</span> <span class="fu">$</span>
    it <span class="st">&quot;should parse two consecutive characters in the hex range into a two character string&quot;</span> <span class="fu">$</span>
      property prop_byte_parse</code></pre></div>
<p>Running the tests with <code>stack test</code> will run this spec and check that the property <code>prop_byte_parse</code> holds when parsing the random values of <code>TwoCharHexString</code> that quickcheck produces - which we defined in our <code>Arbitrary</code> instance.</p>
<p>But wait! The <code>byte</code> function was <code>undefined</code> so the test should fail! Yip, it should give output similar to the following.</p>
<pre><code>...
Assembler
  byte
    should parse two consecutive characters in the hex range into a two character string FAILED [1]

Failures:

  test/AssemblerSpec.hs:19:
  1) Assembler.byte should parse two consecutive characters in the hex range into a two character string
       uncaught exception: ErrorCall (Prelude.undefined
       CallStack (from HasCallStack):
         error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err
         undefined, called at src/Assembler.hs:52:8 in emu-mos6502-asm-blog-0.1.0.0-J3FxRJn8XZkGwqJZfEo09O:Assembler) (after 1 test)
       *** Failed! (after 1 test):
       Exception:
         Prelude.undefined
         CallStack (from HasCallStack):
           error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err
           undefined, called at src/Assembler.hs:52:8 in emu-mos6502-asm-blog-0.1.0.0-J3FxRJn8XZkGwqJZfEo09O:Assembler
       TwoCharHexString &quot;fF&quot;

Randomized with seed 1913513661

Finished in 0.0023 seconds
1 example, 1 failure
...</code></pre>
<p>Good, now we can implement <code>byte</code>. I’ve deliberatly left out some boiler plate such as dependencies and test setup, but you can view the full code up to this point, see <a href="https://github.com/wayofthepie/emu-mos6502-asm-blog/blob/ff2c770ec79dc1b56446b80cff28c6bfc87ca57a/src/Assembler.hs">Assembler.hs</a> for the types and functions and <a href="https://github.com/wayofthepie/emu-mos6502-asm-blog/blob/ff2c770ec79dc1b56446b80cff28c6bfc87ca57a/test/AssemblerSpec.hs">AssemblerSpec.hs</a> for the the property and <code>Arbitrary</code> instance.</p>
<h3 id="implementation">Implementation</h3>
<p>So now that we have a property which defines what our <code>byte</code> function should do, we can implement it. <a href="https://hackage.haskell.org/package/megaparsec-5.2.0/docs/Text-Megaparsec.html#v:hexDigitChar">hexDigitChar</a> is a parser from <em>megaparsec</em> which parses a a hexadecimal digit. A byte is made up of two such digits so <code>byte</code> is simply a parser which tries to parse two hexadecimal chars.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">byte ::</span> <span class="dt">Parser</span> <span class="dt">T.Text</span>
byte <span class="fu">=</span> <span class="kw">do</span>
  high <span class="ot">&lt;-</span> hexDigitChar
  low <span class="ot">&lt;-</span> hexDigitChar
  pure <span class="fu">$</span> T.pack [high,low]</code></pre></div>
<p>Nice! We read a hex char and call it <code>high</code> and another called <code>low</code> and build a <code>Text</code> value.</p>
<p>The rest of the parsers can be implemented in a similar way - define <code>Arbitrary</code> instances for the data they should take, define properties for the expected output and implement!</p>
<p>I’ll leave the rest of the implementation for another post. Running <code>stack test</code> now should give the following output.</p>
<pre><code>...
Assembler
  byte
    should parse two consecutive characters in the hex range into a two character string

Finished in 0.0016 seconds
1 example, 0 failures
...</code></pre>
<p>Excellent, our implementation passed the property check! You can check out the code up to this point <a href="https://github.com/wayofthepie/emu-mos6502-asm-blog/tree/90ccef30de0aac6cc0f74df4e688d392c4607846">here</a>.</p>
<h1 id="conclusion">Conclusion</h1>
<p>This is where I’ll leave this post. I think it’s long enough! In the next post we’ll create the rest of the parsers and their properties, and also run through <em>megaparsec</em> in some more detail. There are definitely quite a few improvements that can be added to the language, and plenty more features that would be useful to have which we can implement in the future.</p>
<p>There are also some limitations in the grammar, for example it currently does not allow <code>X</code> or <code>Y</code> indexed addressing <a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a> - e.g. <code>LDA ($2020,X)</code> - we can address these too.</p>
<p>This post outlines what I have done so far when building the assembler, and really just shows my own thought process around designing and implementing. Im actively working on the 6502 emulator, so I hope to do a post every week. The main goal is to outline my development process in implementing the project, hopefully I’ll introduce some bugs or have some interesting issues along the way!</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The reference I’m using for the emulator is mainly <a href="http://obelisk.me.uk/6502/reference.html" class="uri">http://obelisk.me.uk/6502/reference.html</a>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><a href="http://www.alexeyshmalko.com/2015/haskell-string-types/">Haskell String Types</a> is a good post detailing the different string types.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>See the documentation for <a href="https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Arbitrary.html">Arbitrary</a>, this <a href="https://stackoverflow.com/questions/16440208/how-to-generate-arbitrary-instances-of-a-simple-type-for-quickcheck">StackOverflow answer</a> is also good.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>See the documentation for <a href="https://hackage.haskell.org/package/megaparsec-5.2.0/docs/Text-Megaparsec.html#v:parse">parse</a>.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>See Indexed Indirect, and Indirect Indexed addressing modes <a href="http://www.obelisk.me.uk/6502/addressing.html">here</a>.<a href="#fnref5">↩</a></p></li>
</ol>
</div>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//wayofthepie.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<script id="dsq-count-scr" src="//wayofthepie.disqus.com/count.js" async></script>

        <!-- FIXME : These are here so the footer doesn't cover the last part of the body. Fix! -->
        <br />
        <br />
        <br />
    </div>

    <div class="navbar navbar-default">
        <div class="container-fluid">
            <p class="navbar-text pull-left">&copy; 2018 - Stephen O'Brien.</p>
            <div class="pull-right">
                <a class="btn navbar-btn btn-social-icon btn-github" href="https://github.com/wayofthepie">
                    <span class="fa fa-github"></span>
                </a>
            </div>
        </div>
    </div>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
     <script src="../js/highlight.pack.js" type="text/javascript"></script>
     <script>hljs.initHighlightingOnLoad();</script>
</script>
</div>

</body>
</html>
